---
title: "OOPSLA20 Artifact - Designing Types for R, Empirically"
authors: "Alexi Turcotte, Aviral Goel, Filip Krikava and Jan Vitek"
output: 
  html_document: 
    theme: journal
    toc: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(viewer)

knitr::opts_chunk$set(echo = TRUE)
```

## Artifact Description

This is the artifact for the OOPSLA 2020 paper *Designing Types for R, Empirically*.
The aim is to:

1.  show the tools that were developed to infer and assert types for R
    functions,
2.  demonstrate the entire pipeline used to infer types for R packages.

The artifact is composed of two parts: 

1. a getting started guide that contains the setup instructions and a small
   experiment to verify that all works, and
2. a step-by-step instructions on how the tooling developed for this paper work
   and a complete pipeline which reproduces the data reported in the paper.

## Requirements 

The pipeline depends on a number of tools and R packages:

- bash
- git
- GNU parallel >= 20190322
- GNU bison >= 3.5
- GNU make >= 4.1
- [R](https://cran.r-project.org) == 3.5.0
- [R-dyntrace](https://github.com/PRL-PRG/R-dyntrace) 3.5.0
- a number of our R packages with their dependencies
  - [contractr](https://github.com/PRL-PRG/contractr) - runtime type assertions
  - [injectr](https://github.com/PRL-PRG/injectr) - for injecting code into R functions
  - [propagatr](https://github.com/PRL-PRG/propagatr) - tracing type usage
  - [runr](https://github.com/PRL-PRG/runr) - running the experiments
  - [tastr](https://github.com/PRL-PRG/tastr) - grammar and parser for our R types

and of course a corpus of R packages to be run.

To make it more convenient we have build a docker image that has all these dependencies installed.
The image can be pulled directly from [Docker HUB](https://hub.docker.com/r/prlprg/oopsla20-typer) or <a href="#building-image-locally">built locally</a>.
To use the image, you will need:
- [docker community edition](https://docs.docker.com/install/) version 18+, and 
- bash.

This artifact requires about ~10GB of free space, depending on the number of packages that should be analyzed.
It has been tested on Linux (Manjaro 19 and Ubuntu 18.04).

## Getting Started Guide

For the initial kick-the-tires phase, please go over the following steps to determine if the artifact is usable in your environment.

1. Clone the artifact git repository

```{sh eval=FALSE}
git clone https://github.com/PRL-PRG/OOPSLA20-typer-artifact
cd OOPSLA20-typer-artifact
```

We will refer to the directory in where the artifact is cloned as `$REPO`.
The content of the artifact is discussed in <a href="#artifact-structure">later section</a>.

1. Run RStudio from the artifact docker container

A part of the artifact evaluation can be done from within an interactive session in an [RStudio](https://rstudio.com).
The following command will pull the docker image and start an instance of RStudio at the port 8787.
If you need to use an alternative port, you can specify it using `-p PORT` argument.

```{sh eval=FALSE}
./run.sh
```

Once you see an output like:

```text
[services.d] starting services
[services.d] done.
```

you should be able to access RStudio in your browser at [http://localhost:8787](http://localhost:8787).

To terminate it, simply interrupt the process by pressing `Ctrl-C` / `Command-C`.

1. Open this `README.Rmd` in RStudio

The rest of the steps can be done in the RStudio.
To do that, open this `README.Rmd` file by either navigating to `File` -> `Open File...` menu item or
by running:

```{r eval=FALSE}
navigateToFile("~/README.Rmd")
```

in the R interpreter.
The rest of the command snippets can be run from within R by either clicking the play icon next to the snipper or pressing `Ctrl+Enter` / `Command+Enter`.

1. Check that RStudio can see all installed packages.

First, we need to make sure RStudio can load the `contractr` package.

```{r eval=FALSE}
library(contractr)
```

You shoud see an output similar to this:

```
Loading required package: roxygen2
Added contract to 118 roxygen2 function(s)
No type declarations found for package stats
No type declarations found for package graphics
No type declarations found for package grDevices
No type declarations found for package utils
No type declarations found for package datasets
No type declarations found for package methods
No type declarations found for package base
No type declarations found for package contractr
```

What is means is discussed in a <a href="#types-for-r">later section</a>.

1. Knit `corpus-analysis.Rmd`

Next, we try to build the corpus analyzing notebook.
This can be done with the following command:

```{r eval=FALSE}
rmarkdown::render("~/typeR/analysis/corpus-analysis.Rmd")
```

which, if successfull, generates an HTML file in `~/typeR/analysis/corpus-analysis.Rmd`.
To view it, either open it in the navigator on the right side or run:

```{r eval=FALSE}
viewer("~/typeR/analysis/corpus-analysis.html")
```

1. Try to infer types for tiny corpus of just 2 packages

TODO: Filip

For the last test, we will try to run the type infering pipeline for two packages.

This has to be done in a terminal. 
Navigate to the `$REPO/typeR` and run the following:

```{sh eval=FALSE}
./in-docker.sh make tasks/infer-types PACKAGES_FILE=packages-tiny-corpus.txt JOBS=1
```

The `make` command must be prefixed with `in-docker.sh` as we want to run it inside a docker container.

TODO describe the result

This concludes the getting started guide and the kick the tires part.

## Step-by-step Instructions

### Quick Tutorial

This should happen in Rstudio

#### contractr
<a name="#types-for-r"/>

- run a function with no error
- run a function with error
- inject type
- rerun
- show the error messages from contractr
- plus a bit how it works - it injects into all loaded packages


The `contractr` library helps generates runtime contracts from function type
signatures. It modifies the function body to check for function argument and
return value types. Let us look at how this library works.

First we load `contractr`. It depends on the R package `roxygen2`, which gets
loaded as well. `contractr` comes equipped with type declarations for 395
packages, `roxygen2` being one of them. As shown in the console output below,
when `roxygen2` is loaded, `contractr` automatically inserts contracts to it's
118 functions. In general, `contractr` sets up package load hooks. So if any of
the 395 packages are loaded, `contractr` automatically adds contracts to their
functions. If no type declarations are available for a package, `contractr`
reports that as well.

```{r eval=TRUE}
library(contractr)
```

Now, we load the `stringr` library, for which `contractr` has type declarations.

```{r eval=TRUE}
library(stringr)
```

The aim of `contractr` is to insert runtime type checks and provide meaningful
error messages when the checks are violated. Let us call one of the `stringr`
functions and observe `contractr` in action. For this, we choose the `str_count`
function from `stringr`. This function counts the number of matches of a pattern
in each element of a string vector (character vector in R speak). Here is an
example of a type-correct interaction withe the `str_count` function.


```{r eval=TRUE}
fruit <- c("apple", "banana", "pear", "pineapple")
str_count(fruit, "a")
```

Now, we will pass a pattern value with incorrect type, a double instead of a
character. Firstly, as expected the function terminates with an error because
the pattern argument is not supposed to be a numeric value. Secondly, we observe
two warning messages. These warning messages are provided by `contractr`. The
first message originates from the type checking of the `pattern` argument of
`str_count`. The error message contains the following bits of information:
- Parameter name and position
- Function name
- Expected type
- Actual type
- Stack trace

Since the `str_count` function is called from the top-level, the
stack trace only has a single frame, the `str_count(fruit, 1)` call.

The second warning message originates from a call to the `stringr::type`
function from within the definition of `str_count` function. It turns out that
passing a numeric argument to `str_count` also violates the type declaration of
`type` function. As can be seen from the warning message, the `trace` has size 2
with `type(pattern)` being called from `str_count(fruit, 1)`.

```{r eval=TRUE}
fruit <- c("apple", "banana", "pear", "pineapple")
str_count(fruit, 1)
```

An important point to note here is that `contractr` reports type mismatches as
warnings. Unfortunately, if there are too many warnings, R collects them together
and reports them at the end of the program. It may be desirable to report the
mismatch when it happens and halt the program at that point. `contractr` allows
this behavior to be configured using the `set_severity` function. The default
severity is set to `"warning"`. It can be set to `"error"` to report type
mismatch as an error and stop the program. With this setting, execution halts
with the type mismatch error, so only the first type mismatch is reported.

```{r eval=TRUE}
set_severity("error")
str_count(fruit, 1)
```

Severity can also be set to `"silence"` to ignore all type mismatches. With this
setting, the execution halts with the error message from the function execution.

```{r eval=TRUE}
set_severity("silence")
str_count(fruit, 1)
```

We set the severity back to `"warning"` for the rest of the session.

```{r eval=TRUE}
set_severity("warning")
```

Let's look at how the function definition is modified by `contractr` to enable
the type mismatch checks. If we type the function name on the R console, it
prints out the definition of the function as it parsed from the package code.

```{r eval=TRUE}
str_count
```

However, `contractr` modifies this definition internally, without affecting the
printed representation of the function definition. The modified function body
can be obtained using the `body` function. As shown below, `contractr` adds two
code blocks at the top of the body. The `on.exit` block attaches a function exit
handler to check the type of the return value. The next block checks the type of
all the arguments. The real heavy-lifting happens inside native code. The blocks
immediately call C functions (prefixed with `C_`) using the `.Call` function.
The reason is that `contractr` has to get around R's laziness semantics for
argument type checking. Due to laziness, the arguments to a function call are
unevaluated code thunks (promises). To maintain non-strict evaluation semantics,
`contractr` inserts type-checking and error-reporting logic inside these thunks.
It would have been easier to evaluate thunks at this point and check the type of
arguments values but that would modify the semantics and break code by
prematurely evaluating arguments which may not even be evaluated or perhaps
evaluated in a specific order.

```{r eval=TRUE}
body(str_count)
```

`contractr` comes equipped with type declarations for 395 packages. Furthermore,
type declarations can be provided during package development as part of function
documentation as shown below in the definition of `add3` function. All type
declarations from the `@type` tag are exported to `TYPEDECLARATION` file inside
the package that during the package's installation. These files are
automatically read by `contractr` when the package is loaded.

```{r eval=FALSE}
#' NOTE: running this block has no effect, it has be part of package definition
#' @type <int> => int
add3 <- function(x) {
  x + 3
}
```

`contractr` also provides API to inject type annotations for functions. This is
useful for adding contracts to functions defined interactively on the console.
Note how `contractr` provides type errors for return types and all parameter types.

```{r eval=TRUE}
f <- function(x, y) {
    x + y - 1L
}
insert_contract(f, "<int, int> => int")

f(1L, 2L)

f(1, 2)

f(1L, 2)

f(1, 2L)
```

A user may wish to get all the contract assertions at the end of the sessions.
`contractr` provides an API, `get_contracts`, to query all contract assertions.
The following interaction outputs a large data frame. Each row is a contract
assertion (failed or succeeded). The columns contain information about the
assertions.

```{r eval=TRUE}
get_contracts()
```

`clear_contracts` API clears the internal record of contract assertions.

```{r eval=TRUE}
clear_contracts()
get_contracts()
```

For large programs, a user might be interested in selectively capturing and
ignoring contract assertions. For this, `contractr` provides two functions,
`capture_contracts` and `ignore_contracts` to execute code blocks by enabling
and disabling contract assertion respectively. The two functions can be
arbitrarily nested. `capture_contracts` returns an R list with two fields,
`result` field contains the result of evaluating the code block and `contracts`
field contains the data frame of all contract assertions from the code block.
`ignore_contracts` returns just the result of evaluating the code block as it
does not perform any contract assertions.

In this code block, type checking of argument and return values for `f(1, 2)`
will not happen. Only `f(1L, 2)` will be type checked.

```{r eval=TRUE}
result <- ignore_contracts({
    capture_contracts({
        f(1L, 2)
    })
    f(1, 2)
})
result
```

In this code block, the behavior is reversed.

```{r eval=TRUE}
result <- capture_contracts({
    ignore_contracts({
        f(1L, 2)
    })
    f(1, 2)
})
result
```

In summary, this section has described the design and use of `contractr` library
and discussed the following salient aspects of its design.

- Error messages
- Contract violation severity (silent, warning and error)
- Addition of type annotations as `roxygen2` tags
- Injection of type declarations for custom user-defined functions
- API to get and clear contract assertions
- API to enable and disable contract assertions for code blocks


#### Inferring Types from R Code

FILIP

- run one package
- show the required steps
- and how to get to merged.csv

### Redoing the Paper Experiment

ALEXI

- some intro text what is the experiment (perhaps like in the subsection below - Corpus)

Since the data are too big, please download this ...
Running large experiments involve failure, some code is not always deterministic, ... 

```{r eval=FALSE}
download.file("...")
```

```{r eval=FALSE}
extract
```

#### Expressiveness and Robustness

TODO: ALEXI Chapter 6.1 and 6.2

```{r eval=FALSE}
rmarkdown::render("~/typeR/analysis/evaluation.Rmd")
```

```{r eval=FALSE}
viewer("~/typeR/analysis/evaluation.html")
```

#### Assertions

TODO: FILIP Chapter 6.3

#### Corpus

In this section we show how to generate data presented in __Chapter 5 - Project
Corpus_. We do this in a separate notebook:
`~/typeR/analysis/corpus-analysis.Rmd`.
If you have completed the getting started guide, you have already ran this notebook.
Here we give more details about how it works.

It loads the metadata collected for the whole of CRAN, namely:
- TODO ``
- TODO ``

Since generating this file requires to have all the CRAN packages installed, we
only include the result.

To knit the notebook, run:

```{r eval=FALSE}
rmarkdown::render("~/typeR/analysis/corpus-analysis.Rmd")
```

This will generate the following files:

- `corpus-analysis.html`: an HTML file rendering the notebook

```{r}
viewer("~/typeR/analysis/corpus-analysis.html")
```

- `corpus.tex`: a Latex file with the raw data to be included in the paper

```{r}
viewer("~/typeR/paper/corpus.tex")
```

- `corpus.pdf`: a plot of the corpus 

```{r eval=FALSE}
viewer("~/typeR/paper/plots/corpus.pdf")
```

## Artifact Structure
<a name="#artifact-structure"/>

TODO: FILIP

## Building Image Locally
<a name="#building-image-locally"/>

To build image locally, run the following in `$REPO`:

```{sh eval=FALSE}
make -C docker-image
```

If you do not have GNU make, you can run:

TODO: FILIP

## Toubleshooting

### File Permissions

TODO: FILIP

### Docker on OSX

It is better to use homebrew cask to install docker:

```sh
brew cask install docker
```

in case you see `docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?.` error message
cf: https://stackoverflow.com/a/44719239

### Docker on Linux

In some distribution the package does not add the current user to `docker` group.
In this case, either add yourself to `docker` group or run all docker-related command with `sudo`.

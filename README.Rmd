---
title: "OOPSLA20 Artifact - Designing Types for R, Empirically"
editor_options:
  chunk_output_type: console
output:
  pdf_document:
    toc: yes
  html_document:
    keep_md: yes
    theme: united
    toc: yes
    toc_float: yes
authors: Alexi Turcotte, Aviral Goel, Filip Krikava and Jan Vitek
---

```{r setup, include=FALSE}
library(rstudioapi)

knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This is the artifact for the OOPSLA 2020 paper *Designing Types for R, Empirically*.
The aim is to show the tools that were developed to infer and assert types for R functions and R packages.

The artifact is composed of two parts: 

1. a _getting started guide_ that contains the setup instructions and a small experiment to verify that the artifact is usable, and
2. a _step-by-step instructions_ how to run the tools developed for this paper and how to reproduce the data reported in the paper.

## Requirements 

The pipeline depends on a number of tools and R packages:

- bash
- git
- GNU parallel >= 20190322
- GNU bison >= 3.5
- GNU make >= 4.1
- [R](https://cran.r-project.org) == 3.5.0
- [R-dyntrace](https://github.com/PRL-PRG/R-dyntrace) 3.5.0
- a number of our R packages with their dependencies
  - [contractr](https://github.com/PRL-PRG/contractr) - runtime type assertions
  - [injectr](https://github.com/PRL-PRG/injectr) - for injecting code into R functions
  - [propagatr](https://github.com/PRL-PRG/propagatr) - tracing type usage
  - [runr](https://github.com/PRL-PRG/runr) - running the experiments
  - [tastr](https://github.com/PRL-PRG/tastr) - grammar and parser for our R types

and of course a corpus of R packages to be run.

To make it more convenient we have build a docker image that has all these dependencies installed.
The image can be pulled directly from [Docker HUB](https://hub.docker.com/r/prlprg/oopsla20-typer) or <a href="#building-image-locally">built locally</a>.
To use the image, you will need:
- git
- bash, and
- [docker community edition](https://docs.docker.com/install/) version 18+.

This artifact requires about ~20GB of free space, depending on the number of packages that should be analyzed.
It has been tested on Linux (Manjaro 19 and Ubuntu 18.04).

## Getting Started Guide

For the initial kick-the-tires phase, please go over the following steps to determine if the artifact is usable in your environment.

1. Clone the artifact git repository
   
   In a terminal, run the following to get a copy of the artifact repository:

   ```{sh eval=FALSE}
   git clone https://github.com/PRL-PRG/OOPSLA20-typer-artifact
   cd OOPSLA20-typer-artifact
   ```
  
   We will refer to this directory as `$REPO`.
   
   The artifact has the follwing structure:
   
   ```
   .
   ├── docker-image -- files needed to build the image
   ├── README.Rmd   -- this readme in R markdown format
   ├── README.md    -- this readme in markdown format
   ├── run.sh       -- script to run Rstudio
   └── typeR        -- directory in which the type inference pipeline runs
       ├── data-corpus.tar.xz   -- archived data from analyzing the full 412 package corpus
       ├── in-docker.sh         -- a helper script executinig given command in a container
       ├── Makefile             -- makefile orchestrating the type inference pipeline
       ├── notebooks            
       │   ├── corpus-analysis.Rmd     -- data points for paper's Chapter 5
       │   ├── evaluation-asserts.Rmd  -- data points for paper's Chapter 6.3
       │   ├── evaluation.Rmd          -- data points for paper's Chapter 6.{1,2}
       │   └── inc                     -- auxiliary R files for data analysis
       ├── packages-corpus.txt         -- list of the 412 packages
       ├── packages-small-corpus.txt   -- a smaller corpus to be run during the artifact evaluation
       ├── packages-tiny-corpus.txt    -- a tiny corpus to be run during the kcik the tires phase
       ├── scripts                     -- auxiliary scripts
       └── type-analyzer               -- type analyzer source code
   ```

1. Run RStudio from the artifact docker container

   To make the artifact evaluation a bit more convenient, the docker image includes [RStudio](https://rstudio.com), a propular R IDE.
   The following command will pull the docker image from Docker HUB and start an instance of RStudio on port 8787.
   If you need to use an alternative port, you can specify it using `-p PORT` argument to the `run.sh` script.
    
   ```{sh eval=FALSE}
   ./run.sh
   ```
    
   Once you see an output like:
    
   ```text
   [services.d] starting services
   [services.d] done.
   ```
    
   you should be able to access RStudio in your browser at [http://localhost:8787](http://localhost:8787).
    
   To terminate it, simply interrupt the process by pressing `Ctrl-C` / `Command-C`.

1. Open this readme (`README.Rmd`) in RStudio

   The rest of the steps in this guide can be done directly in the RStudio.
   To do that, open this readme file `README.Rmd` file by either navigating to `File` -> `Open File...` menu item or
   by running the following in the R interpreter:
    
   ```{r eval=FALSE}
   navigateToFile("~/README.Rmd")
   ```
    
   The file is written in [Rmarkdown](https://rmarkdown.rstudio.com/) (or Rmd), also referred to as notebooks.
   It is essentially a markdown document with code snippets.
   These snippets can be run directly from RStudio.
   Rmd files can be also rendered (_knitted_) to various output file formats running all code snippes and embedding their outputs directly to the resulting file.
   Next to this readme file, we use several of the Rmd files to analyze the data for the paper.
    
   The rest of the code snippets can be run from within R by either clicking the play icon next to the snipper or by placing cursor somewhere inside the snippet and pressing `Ctrl+Enter` / `Command+Enter`.

1. Check that RStudio can load contractr package.

   First, we need to make sure RStudio can load the `contractr` package.
    
   ```{r eval=FALSE}
   library(contractr)
   ```
    
   You shoud see an output similar to this:
    
   ```
   Loading required package: roxygen2
   Added contract to 118 roxygen2 function(s)
   No type declarations found for package stats
   No type declarations found for package graphics
   No type declarations found for package grDevices
   No type declarations found for package utils
   No type declarations found for package datasets
   No type declarations found for package methods
   No type declarations found for package base
   No type declarations found for package contractr
   ```
    
   What is means is discussed in a <a href="#types-for-r">later section</a>.

1. Try to infer types for tiny corpus of just 2 packages

   For the last test, we will try to run the type infering pipeline for a single package: stringr.
  
   This has to be done in a terminal. 
   Navigate to the `$REPO/typeR` and run the following:
  
   ```{sh eval=FALSE}
   ./in-docker.sh make clean all PACKAGES_FILE=packages-tiny-corpus.txt 
   ```
  
   The `make` command must be prefixed with `in-docker.sh` as we want to run it inside a docker container.
  
   The result should be `$REPO/typeR/data` with the following files:
   
   ```
   data
   ├── assertions-all.csv
   ├── assertions-failed.csv
   ├── type-analysis
   │   ├── merged.csv
   │   └── packages
   │       └── stringr.csv
   ├── TYPEDECLARATION
   │   └── stringr           -- the actual inferred types
   └── type-traces.csv
   ```

   The `data/assertions-all.csv` file contains all the assertions.
   The `data/assertions-failed.csv` file contains only failed assertions.
   The `data/type-analysis/packages/<package>.csv` file contains information about type signatures of `<package>` functions.
   The `data/type-analysis/merged.csv` file contains information about type signatures of functions from all packages.
   The `data/TYPEDECLARATION/<package>` files contain type declarations for all functions from the traced packages.
   The `data/type-traces.csv` file contains type traces obtained from dynamic analysis of package code.

This concludes the getting started guide and the kick the tires part.

## Step-by-step Instructions

### Quick Tutorial

This should happen in Rstudio

#### contractr
<a name="#types-for-r"/>

The `contractr` library helps generates runtime contracts from function type
signatures. It modifies the function body to check for function argument and
return value types. Let us look at how this library works.

First we load `contractr`. It depends on the R package `roxygen2`, which gets
loaded as well. `contractr` comes equipped with type declarations for 395
packages, `roxygen2` being one of them. As shown in the console output below,
when `roxygen2` is loaded, `contractr` automatically inserts contracts to it's
118 functions. In general, `contractr` sets up package load hooks. So if any of
the 395 packages are loaded, `contractr` automatically adds contracts to their
functions. If no type declarations are available for a package, `contractr`
reports that as well.

```{r eval=TRUE}
library(contractr)
```

Now, we load the `stringr` library, for which `contractr` has type declarations.

```{r eval=TRUE}
library(stringr)
```

The aim of `contractr` is to insert runtime type checks and provide meaningful
error messages when the checks are violated. Let us call one of the `stringr`
functions and observe `contractr` in action. For this, we choose the `str_count`
function from `stringr`. This function counts the number of matches of a pattern
in each element of a string vector (character vector in R speak). Here is an
example of a type-correct interaction withe the `str_count` function.


```{r eval=TRUE}
fruit <- c("apple", "banana", "pear", "pineapple")
str_count(fruit, "a")
```

Now, we will pass a pattern value with incorrect type, a double instead of a
character. Firstly, as expected the function terminates with an error because
the pattern argument is not supposed to be a numeric value. Secondly, we observe
two warning messages. These warning messages are provided by `contractr`. The
first message originates from the type checking of the `pattern` argument of
`str_count`. The error message contains the following bits of information:
- Parameter name and position
- Function name
- Expected type
- Actual type
- Stack trace

Since the `str_count` function is called from the top-level, the
stack trace only has a single frame, the `str_count(fruit, 1)` call.

The second warning message originates from a call to the `stringr::type`
function from within the definition of `str_count` function. It turns out that
passing a numeric argument to `str_count` also violates the type declaration of
`type` function. As can be seen from the warning message, the `trace` has size 2
with `type(pattern)` being called from `str_count(fruit, 1)`.

```{r eval=TRUE, error=TRUE}
fruit <- c("apple", "banana", "pear", "pineapple")
str_count(fruit, 1)
```

An important point to note here is that `contractr` reports type mismatches as
warnings. Unfortunately, if there are too many warnings, R collects them together
and reports them at the end of the program. It may be desirable to report the
mismatch when it happens and halt the program at that point. `contractr` allows
this behavior to be configured using the `set_severity` function. The default
severity is set to `"warning"`. It can be set to `"error"` to report type
mismatch as an error and stop the program. With this setting, execution halts
with the type mismatch error, so only the first type mismatch is reported.

```{r eval=TRUE, error=TRUE}
set_severity("error")
str_count(fruit, 1)
```

Severity can also be set to `"silence"` to ignore all type mismatches. With this
setting, the execution halts with the error message from the function execution.

```{r eval=TRUE, error=TRUE}
set_severity("silence")
str_count(fruit, 1)
```

We set the severity back to `"warning"` for the rest of the session.

```{r eval=TRUE}
set_severity("warning")
```

Let's look at how the function definition is modified by `contractr` to enable
the type mismatch checks. If we type the function name on the R console, it
prints out the definition of the function as it parsed from the package code.

```{r eval=TRUE}
str_count
```

However, `contractr` modifies this definition internally, without affecting the
printed representation of the function definition. The modified function body
can be obtained using the `body` function. As shown below, `contractr` adds two
code blocks at the top of the body. The `on.exit` block attaches a function exit
handler to check the type of the return value. The next block checks the type of
all the arguments. The real heavy-lifting happens inside native code. The blocks
immediately call C functions (prefixed with `C_`) using the `.Call` function.
The reason is that `contractr` has to get around R's laziness semantics for
argument type checking. Due to laziness, the arguments to a function call are
unevaluated code thunks (promises). To maintain non-strict evaluation semantics,
`contractr` inserts type-checking and error-reporting logic inside these thunks.
It would have been easier to evaluate thunks at this point and check the type of
arguments values but that would modify the semantics and break code by
prematurely evaluating arguments which may not even be evaluated or perhaps
evaluated in a specific order.

```{r eval=TRUE}
body(str_count)
```

`contractr` comes equipped with type declarations for 395 packages. Furthermore,
type declarations can be provided during package development as part of function
documentation as shown below in the definition of `add3` function. All type
declarations from the `@type` tag are exported to `TYPEDECLARATION` file inside
the package that during the package's installation. These files are
automatically read by `contractr` when the package is loaded.

```{r eval=FALSE}
#' NOTE: running this block has no effect, it has be part of package definition
#' @type <int> => int
add3 <- function(x) {
  x + 3
}
```

`contractr` also provides API to inject type annotations for functions. This is
useful for adding contracts to functions defined interactively on the console.
Note how `contractr` provides type errors for return types and all parameter types.

```{r eval=TRUE}
f <- function(x, y) {
    x + y - 1L
}
insert_contract(f, "<int, int> => int")

f(1L, 2L)

f(1, 2)

f(1L, 2)

f(1, 2L)
```

A user may wish to get all the contract assertions at the end of the sessions.
`contractr` provides an API, `get_contracts`, to query all contract assertions.
The following interaction outputs a large data frame. Each row is a contract
assertion (failed or succeeded). The columns contain information about the
assertions.

```{r eval=TRUE}
get_contracts()
```

`clear_contracts` API clears the internal record of contract assertions.

```{r eval=TRUE}
clear_contracts()
get_contracts()
```

For large programs, a user might be interested in selectively capturing and
ignoring contract assertions. For this, `contractr` provides two functions,
`capture_contracts` and `ignore_contracts` to execute code blocks by enabling
and disabling contract assertion respectively. The two functions can be
arbitrarily nested. `capture_contracts` returns an R list with two fields,
`result` field contains the result of evaluating the code block and `contracts`
field contains the data frame of all contract assertions from the code block.
`ignore_contracts` returns just the result of evaluating the code block as it
does not perform any contract assertions.

In this code block, type checking of argument and return values for `f(1, 2)`
will not happen. Only `f(1L, 2)` will be type checked.

```{r eval=TRUE}
result <- ignore_contracts({
    capture_contracts({
        f(1L, 2)
    })
    f(1, 2)
})
result
```

In this code block, the behavior is reversed.

```{r eval=TRUE}
result <- capture_contracts({
    ignore_contracts({
        f(1L, 2)
    })
    f(1, 2)
})
result
```

In summary, this section has described the design and use of `contractr` library
and discussed the following salient aspects of its design.

- Error messages
- Contract violation severity (silent, warning and error)
- Addition of type annotations as `roxygen2` tags
- Injection of type declarations for custom user-defined functions
- API to get and clear contract assertions
- API to enable and disable contract assertions for code blocks


#### Inferring Types from R Code

FILIP

- run one package
- show the required steps
- and how to get to merged.csv

### Redoing the Paper Experiment

In this section, we present an R Notebook capable of reproducing the figures and key numbers seen in the paper.

To obtain the data for the paper, we conducted an experiment wherein we chose a subset of CRAN packages with > 5 reverse dependencies and > 65% code coverage.
We ran our type tracing tool on the runnable test, example, and vignette code for these packages, and obtained types for exported package functions.
Then, we loaded those types into the aformentioned `contractr` tool, and ran the test, example, and vignette code of the clients of our core corpus.
We recorded contract assertion successes and failures during this stage of the evaluation.

As you may guess, the data we worked with is too large to be reasonably processed on standard computers.
Our data collection and processing pipeline ran on the order of days on a powerful server with 72 cores and 255GB of RAM.
To that end, we packaged our data and include it with this artifact.
The data itself is liable to be useful to any future type-based research of R.

Note: as you conduct your evaluation, you will find a number of small discrepancies between the numbers seen here and those in the paper.
Running large experiments involves random failures, nondeterministic function behaviour, and weird environment configurations leading to sporadic issues.
These discrepancies are very minor, amounting to differences on the order of fractions of a percent, and we don't believe this issue to be a cause for major concern.

We refer the reader to `~/typeR/notebooks/evaluation.Rmd` for the analysis. 


To rerun the analysis, first we have to extract the data for the entire corpus:

```sh
./in-docker.sh make data-corpus-dir
```

These should gives us similar files as in the previous section where we only analyzed a few packages.

Next step is to render the `evaluation.Rmd` using:

```sh
./in-docker.sh make evaluation
```

#### Assertions

TODO: FILIP Chapter 6.3

#### Corpus
<a name="#corpus-analysis"/>

TODO: FILIP

In this section we show how to generate data presented in __Chapter 5 - Project
Corpus_. We do this in a separate notebook:
`~/typeR/analysis/corpus-analysis.Rmd`.
If you have completed the getting started guide, you have already ran this notebook.
Here we give more details about how it works.

It loads the metadata collected for the whole of CRAN, namely:
- TODO ``
- TODO ``

Since generating this file requires to have all the CRAN packages installed, we
only include the result.

To knit the notebook, run:

```{r eval=FALSE}
rmarkdown::render("~/typeR/analysis/corpus-analysis.Rmd")
```

This will generate the following files:

- `corpus-analysis.html`: an HTML file rendering the notebook

```{r eval=FALSE}
viewer("~/typeR/analysis/corpus-analysis.html")
```

- `corpus.tex`: a Latex file with the raw data to be included in the paper

```{r eval=FALSE}
viewer("~/typeR/paper/corpus.tex")
```

- `corpus.pdf`: a plot of the corpus 

```{r eval=FALSE}
viewer("~/typeR/paper/plots/corpus.pdf")
```

## Building Image Locally
<a name="#building-image-locally"/>

To build image locally, run the following in `$REPO`:

```{sh eval=FALSE}
make -C docker-image
```

If you do not have GNU make, you can run:

TODO: FILIP

## Toubleshooting

### File Permissions

The problem with docker is that it runs as root and so do its containers.
A common trick is to setup a user in an entrypoint script which will have the same UID and GID as the current user on the host system and then run the rest of the script as that user.
Even though we have tried that, it does not work since GNU parallel cannot then reliably set working directory using the `--workdir` flag.
In the current version therefore, all the generated files will be owned by root user.

To mitigate this problem, at least partially, the `in-docker.sh` script at the end runs:

```sh
docker run \
    --rm \
    -v "$base_dir/typeR:/home/rstudio/typeR" \
    prlprg/oopsla20-typer \
    chown -R $(id -u):$(id -g) /home/rstudio/typeR
```

### Docker on OSX

It is better to use homebrew cask to install docker:

```sh
brew cask install docker
```

in case you see `docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?.` error message
cf: https://stackoverflow.com/a/44719239

### Docker on Linux

In some distribution the package does not add the current user to `docker` group.
In this case, either add yourself to `docker` group or run all docker-related command with `sudo`.
